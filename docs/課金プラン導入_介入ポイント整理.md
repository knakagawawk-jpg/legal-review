# 課金プラン導入：介入ポイント整理

現在のユーザー認証に**課金プラン**を追加するにあたり、「どこに」「どのプロセスを」介入させるかを整理したドキュメントです。

---

## 1. 現状の整理

### 1.1 認証フロー（変更しない想定）

| 段階 | 場所 | 処理 |
|------|------|------|
| ログイン | フロント → `POST /api/auth/google` → バック `POST /v1/auth/google` | Google ID トークン検証 → `get_or_create_user()` → JWT 発行 → ユーザー情報返却 |
| 認証の検証 | 各 API | `get_current_user` / `get_current_user_required`（JWT 検証 → DB から User 取得） |
| ユーザー情報取得 | `GET /api/users/me` → `GET /v1/users/me` | 認証必須で現在ユーザー情報を返す |

**関連ファイル**

- バック: `app/auth.py`（`verify_google_token`, `get_or_create_user`, `create_access_token`, `get_current_user`, `get_current_user_required`）
- バック: `app/main.py`（`/v1/auth/google`, `/v1/users/me`）
- フロント: `web_next/contexts/auth-context.tsx`, `web_next/components/auth/with-auth.tsx`, `web_next/app/api/auth/google/route.ts`, `web_next/app/api/users/me/route.ts`

### 1.2 プラン・制限の現状（すでに存在）

- **データ**: `SubscriptionPlan`, `UserSubscription`（`app/models.py`）
- **ロジック**: `app/plan_limits.py`  
  - `get_default_plan()` / `get_user_plan()` でユーザーに適用されるプランを決定  
  - 有効な `UserSubscription` がなければデフォルトプラン（`DEFAULT_PLAN_CODE`）を適用  
  - 各種 `check_*_limit()` で使用量と上限を比較し、超過時は 429
- **API**: `GET /v1/users/me/plan-limits` でプラン名・制限値・使用量を返却
- **フロント**: `your-page/data` でプラン制限・使用量を表示

**制限チェックが入っている API（main.py）**

- 講評作成: `check_review_limit`
- 講評チャット・フリーチャット メッセージ送信: `check_review_chat_message_limit` / `check_free_chat_message_limit`, `check_non_review_cost_limit`
- 復習問題生成: `check_recent_review_daily_limit`, `check_non_review_cost_limit`

---

## 2. 課金プラン導入で介入する「場所」と「プロセス」

課金を「プラン選択・支払い・契約期間管理」として扱う場合の介入ポイントです。

### 2.1 認証直後（ログイン・新規登録）

| 介入場所 | ファイル・エンドポイント | 介入するプロセス |
|----------|---------------------------|------------------|
| 新規ユーザー作成時 | `app/auth.py` の `get_or_create_user()` | 新規ユーザーに対して「無料プラン」の `UserSubscription` を自動作成するか、または従来どおり「プラン未割り当て＝デフォルトプラン適用」のままにするかを決める。課金導入時は「無料プラン」を明示的にレコードで持つ方が運用しやすい場合あり。 |
| ログイン応答 | `app/main.py` の `POST /v1/auth/google` のレスポンス | （任意）返却 JSON に `plan_code` や `subscription_status` を追加し、フロントでログイン直後にプラン表示・リダイレクトに使う。 |

**結論**: 認証フローそのものは変えず、「新規ユーザーとデフォルトプランの紐付け」と「ログイン応答にプラン情報を含めるか」の 2 点で介入。

---

### 2.2 プラン・契約の「見る」処理

| 介入場所 | ファイル・エンドポイント | 介入するプロセス |
|----------|---------------------------|------------------|
| プラン一覧取得 | **新規** `GET /v1/plans` または `GET /v1/subscription-plans` | 課金対象として公開するプラン一覧（名前・価格・limits・表示順）を返す。既存の `SubscriptionPlan` を利用。 |
| 現在のプラン・使用量 | 既存 `GET /v1/users/me/plan-limits` | そのまま利用可能。必要に応じて「契約状態」（有効・期限切れ・解約予定など）をレスポンスに追加。 |
| 契約履歴・請求履歴 | **新規** `GET /v1/users/me/subscriptions` など | 現在の契約＋過去の契約（`UserSubscription` の履歴）を返す。請求書 ID などは決済基盤連携後に拡張。 |

**フロント**

- プラン一覧ページ（料金表・プラン選択）の追加
- 既存の `your-page/data` の「プラン制限・使用量」表示を、課金プラン用の文言・アップグレード誘導に拡張

---

### 2.3 プラン変更・課金の「決める・実行する」処理（新規が中心）

| 介入場所 | 想定エンドポイント・処理 | 介入するプロセス |
|----------|---------------------------|------------------|
| 有料プラン申し込み | **新規** `POST /v1/users/me/subscriptions` または `POST /v1/checkout` | 選択したプラン ID を受け取り、決済基盤（Stripe 等）の Checkout Session や Payment Link を生成し、フロントに URL を返す。まだ決済基盤を入れない場合は「申し込み希望」を保存するだけでも可。 |
| 決済完了の通知 | **新規** Webhook エンドポイント（例: `POST /v1/webhooks/stripe`） | 決済基盤から「支払い成功」を受け取り、`UserSubscription` を新規作成または更新（`started_at` / `expires_at` 設定）。ここが「課金」と「利用可能プラン」を結びつける要。 |
| プラン解約・ダウングレード | **新規** `PATCH /v1/users/me/subscriptions/current` など | 解約フラグや `cancelled_at` を立て、期限までは有料のまま・期限後にデフォルトプランへフォールバック。`get_user_plan()` は「有効かつ未解約」な `UserSubscription` を優先するので、既存ロジックと整合させる。 |

**依存**

- 決済基盤（Stripe / 他の PSP）の選定と設定
- 環境変数（API キー、Webhook シークレット）の追加

---

### 2.4 既存の「制限チェック」への介入

| 介入場所 | ファイル | 介入するプロセス |
|----------|----------|------------------|
| プラン解決ロジック | `app/plan_limits.py` の `get_user_plan()` | 現状の「有効な UserSubscription → なければデフォルトプラン」はそのまま使える。課金導入後は「有料プラン」を `UserSubscription` で持たせ、`SubscriptionPlan.limits` で上限を変えるだけ。**既存の check_* は原則そのまま**。 |
| 制限超過時のメッセージ | `app/plan_limits.py` の各 `check_*_limit()` | メッセージを「アップグレードしてください」など課金誘導に変更するか、または `PlanLimitUsageResponse` と組み合わせてフロントで誘導する。 |
| 新規の制限種別 | `app/plan_limits.py` + `SubscriptionPlan.limits` のスキーマ | 新しい課金単位（例: 講評の高度機能）を追加する場合、`limits` にキーを追加し、対応する `count_*` と `check_*` を追加。 |

**結論**: 既存の制限チェックは「プランが変わる」だけで動くので、**課金の介入は主に「誰にどのプラン（UserSubscription）を付与するか」**。check 自体の挿入箇所は現状のままでよい。

---

### 2.5 管理側（運用・管理画面）

| 介入場所 | 想定 | 介入するプロセス |
|----------|------|------------------|
| プラン・価格の管理 | 管理 API または DB 直接 | `SubscriptionPlan` の CRUD、`price_monthly` / `price_yearly` の設定。既存の `is_active` で公開/非公開を切り替え。 |
| ユーザーへのプラン付与 | 管理 API またはスクリプト | 特定ユーザーに `UserSubscription` を手動で作成（キャンペーン・テスト用）。既存の `get_user_plan()` がそのまま効く。 |
| 請求・利用状況の確認 | 管理画面・レポート | `UserSubscription` と LlmRequest 等の利用量を集計。必要なら **新規** 管理用 API。 |

---

## 3. プロセス単位のまとめ（どこに何を足すか）

| プロセス | 介入の種類 | 主な場所 |
|----------|------------|----------|
| ログイン・新規登録 | 新規ユーザーとデフォルトプランの紐付け、ログイン応答にプラン情報 | `auth.py`（get_or_create_user）、`main.py`（/v1/auth/google） |
| プラン一覧・現在プラン表示 | 新規 API、既存 API の拡張 | **新規** `/v1/plans`、既存 `/v1/users/me/plan-limits`、フロント プラン・データページ |
| 申し込み・決済 | 新規 API、Webhook | **新規** 申し込み/Checkout 用 API、**新規** Webhook、`UserSubscription` 作成・更新 |
| 解約・ダウングレード | 新規 API | **新規** 契約更新用 API、`UserSubscription.cancelled_at` 等 |
| 利用制限の適用 | 既存ロジックの拡張 | `plan_limits.py`（メッセージや limits キーの追加）、既存 check 呼び出しは維持 |
| 管理・運用 | 管理 API またはスクリプト | 管理用エンドポイント、または既存管理画面から DB 操作 |

---

## 4. 実装順序の提案

1. **データ・既存ロジックの確認**  
   - `SubscriptionPlan` のシード（無料・有料の plan_code）、`UserSubscription` の有無と `get_user_plan()` の挙動を確認。
2. **「見る」ところから**  
   - プラン一覧 API（`GET /v1/plans`）、既存の `plan-limits` の拡張、フロントの料金表・現在プラン表示。
3. **「決める」ところ**  
   - 決済基盤選定 → 申し込み API → Webhook で `UserSubscription` 作成・更新。
4. **解約・ダウングレード**  
   - 解約 API と `get_user_plan()` の「有効な契約」条件の整合。
5. **管理・運用**  
   - 管理画面またはスクリプトでプラン・ユーザー契約を操作できるようにする。

この順で進めると、認証はそのままに「課金プラン」だけを段階的に載せていけます。

---

## 5. 追加要件反映：PlanA / PlanB / PlanC + review追加チケット

### 5.1 プラン設計（確定値）

| プラン | plan_code | Review | Free Chat | 復習問題生成/日 | Review Chat | 非Review合計コスト上限 |
|--------|-----------|--------|-----------|------------------|-------------|------------------------|
| PlanA | `basic_plan` | 8 | 200 | 3 | 200 | 900円 |
| PlanB | `first_month_fm_dm` | 8 | 200 | 3 | 200 | 900円 |
| PlanC | `high_plan` | 20 | 500 | 5 | 500 | 2000円 |

- PlanBは「DMリンク登録時の初月限定」で、制限値はPlanAと同一
- 具体値は `SubscriptionPlan.limits` に保存し、コードにハードコードしない

### 5.2 review追加チケットの考え方

「プラン上限」とは別に、追加購入分を Review 作成にだけ使えるようにする。

#### 判定式（実際の制限判定）

- 追加チケットは **1枚につき review 2回追加**
- `実効review上限 = プラン上限 + 追加チケット由来の合計追加回数`
- `reviews_used >= 実効review上限` なら 429

本設計では「都度消費レコード」を持たず、`reviews_used` と付与済み追加回数の合算で判定する。

### 5.3 追加テーブル（推奨）

`user_review_ticket_grants`（購入・付与履歴）

- `id`
- `user_id`
- `ticket_count`（購入/付与枚数）
- `reviews_per_ticket`（固定値2）
- `total_bonus_reviews`（`ticket_count * 2`）
- `source_type`（`purchase` / `admin_grant` / `campaign`）
- `payment_id`（決済紐付け）
- `created_at`, `updated_at`

### 5.4 既存ロジックへの介入点（重要）

| 介入場所 | 変更内容 |
|----------|----------|
| `app/plan_limits.py` の `check_review_limit()` | `max_reviews_total` 判定を「プラン上限のみ」から「プラン上限 + 追加チケット由来の追加回数」を見るよう変更 |
| `GET /v1/users/me/plan-limits` | `base_reviews_limit`, `review_ticket_count_total`, `review_ticket_bonus_total`, `effective reviews_limit` をレスポンス追加 |
| フロント表示 | 「プラン上限」「追加チケット残」「合計利用可能枠」を分けて表示 |

### 5.5 API追加（最小）

- `GET /v1/users/me/review-tickets`  
  ユーザーのチケット残高・履歴を返す
- `POST /v1/review-tickets/checkout`  
  追加チケット購入の決済開始（Checkout URL返却）
- `POST /v1/webhooks/stripe`  
  決済成功時に `user_review_tickets` へ付与レコードを作成

### 5.6 優先順（この要件向け）

1. PlanA/B/C の `SubscriptionPlan` データ投入
2. `check_review_limit()` を「実効review上限」方式に変更
3. `user_review_tickets` とチケット残高取得 API を追加
4. 購入 API + Webhook でチケット自動付与
5. フロントで残数表示と購入導線追加
