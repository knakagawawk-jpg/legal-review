# 科目管理設計の比較検討

## 前提条件
- 科目は**18個固定**で変更されない
- 既に`FIXED_SUBJECTS`で順序が定義されている
- `DashboardItem`は既に1-18の数字で管理している

## アプローチ1: ID管理（データベース正規化）

### 実装方法
- `Subject`テーブルで科目を管理
- 各テーブルで`subject_id`（ForeignKey）を使用
- 表示時にJOINして科目名を取得

### メリット
1. **データベースの正規化**
   - リレーショナルデータベースのベストプラクティスに従う
   - 外部キー制約で整合性を保証

2. **将来の拡張性**
   - 科目名の変更が容易（1箇所の変更で全体に反映）
   - 科目の追加・削除が可能（ただし18個固定なので不要）

3. **データ整合性**
   - 存在しない科目IDは保存できない
   - タイポや表記ゆれを防止

### デメリット
1. **複雑性の増加**
   - JOIN処理が必要
   - マイグレーションが必要
   - エラーハンドリングが複雑

2. **パフォーマンス**
   - JOIN処理によるオーバーヘッド（ただし18件なので無視できるレベル）

3. **実装コスト**
   - モデル定義の変更
   - APIエンドポイントの修正（47箇所）
   - スキーマの修正
   - マイグレーションスクリプトの作成

## アプローチ2: 数字管理（1-18の固定マッピング）

### 実装方法
- すべてのテーブルで`subject`を`Integer`（1-18）で保存
- 表示時に`SUBJECT_MAP[subject_id]`で科目名に変換
- バックエンド・フロントエンドで共通のマッピング定義

### メリット
1. **シンプルさ**
   - JOIN不要
   - マイグレーション不要（既存データをそのまま使用可能）
   - 実装が簡単

2. **パフォーマンス**
   - JOIN処理がないため高速
   - インデックスが効きやすい

3. **実装コストが低い**
   - モデル定義の変更のみ
   - APIエンドポイントの修正が少ない
   - 既存の`DashboardItem`と同じ方式

4. **型安全性**
   - CHECK制約で1-18のみ許可
   - マジックナンバーを防止

### デメリット
1. **マッピングロジックの分散**
   - バックエンドとフロントエンドで同じマッピングを定義する必要
   - ただし、既に`FIXED_SUBJECTS`が存在するので問題なし

2. **科目名変更時の対応**
   - マッピング定義を複数箇所で更新する必要
   - ただし、18個固定で変更されない前提なので問題なし

3. **データベースの正規化原則に反する**
   - ただし、固定値の場合は許容される設計パターン

## 推奨: アプローチ2（数字管理）

### 理由

1. **18個固定という前提**
   - 科目が固定されているため、正規化のメリットが小さい
   - マッピング定義を1箇所に集約すれば十分

2. **既存実装との整合性**
   - `DashboardItem`が既に1-18で管理している
   - `FIXED_SUBJECTS`が既に定義されている

3. **実装コスト**
   - ID管理: モデル修正 + 47箇所のAPI修正 + マイグレーション
   - 数字管理: モデル修正のみ（APIはそのまま動作）

4. **パフォーマンス**
   - JOIN処理が不要で高速

### 実装方針

#### 1. 共通マッピング定義の作成

**バックエンド** (`config/subjects.py`):
```python
# 科目マッピング（1-18）
SUBJECT_MAP = {
    1: "憲法",
    2: "行政法",
    3: "民法",
    4: "商法",
    5: "民事訴訟法",
    6: "刑法",
    7: "刑事訴訟法",
    8: "実務基礎（民事）",
    9: "実務基礎（刑事）",
    10: "倒産法",
    11: "租税法",
    12: "経済法",
    13: "知的財産法",
    14: "労働法",
    15: "環境法",
    16: "国際関係法（公法系）",
    17: "国際関係法（私法系）",
    18: "一般教養科目",
}

# 逆マッピング（科目名→ID）
SUBJECT_NAME_TO_ID = {name: id for id, name in SUBJECT_MAP.items()}
```

**フロントエンド** (`lib/subjects.ts`):
```typescript
export const SUBJECT_MAP: Record<number, string> = {
  1: "憲法",
  2: "行政法",
  // ... 既存のFIXED_SUBJECTSと同じ順序
  18: "一般教養科目",
} as const

export const SUBJECT_ID_TO_NAME = (id: number): string => {
  return SUBJECT_MAP[id] || "不明"
}

export const SUBJECT_NAME_TO_ID = (name: string): number | null => {
  const entry = Object.entries(SUBJECT_MAP).find(([_, n]) => n === name)
  return entry ? parseInt(entry[0]) : null
}
```

#### 2. モデル定義の変更

```python
# すべてのテーブルで
subject = Column(Integer, nullable=False)  # 1-18
# CHECK制約で1-18のみ許可
CheckConstraint("subject BETWEEN 1 AND 18", name="ck_subject")
```

#### 3. APIエンドポイントの修正

- リクエスト: `subject: int`（1-18）または`subject_name: str`（名前からIDに変換）
- レスポンス: `subject: int`（ID）と`subject_name: str`（表示用）の両方を返す

#### 4. 既存データの移行

- 文字列の科目名をIDに変換するマイグレーションスクリプト
- ただし、既存データが少なければ手動でも可能

## 結論

**アプローチ2（数字管理）を推奨**

理由:
1. 18個固定という前提に最適
2. 実装がシンプルでコストが低い
3. 既存実装（`DashboardItem`）との整合性
4. パフォーマンスが良い
5. マイグレーションが不要（既存データをそのまま使用可能）

ただし、以下の点に注意:
- マッピング定義を1箇所に集約（バックエンド・フロントエンドで同期）
- 科目名変更時はマッピング定義を更新（ただし18個固定なので発生しない想定）
