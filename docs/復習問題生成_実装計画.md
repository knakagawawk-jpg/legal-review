# 復習問題生成機能リニューアル - 実装計画

## 実装フェーズ

### フェーズ1: データベーススキーマ追加

#### 1.1 content_usesテーブルの作成
- **ファイル**: `app/models.py`
- **テーブル名**: `content_uses`
- **カラム**:
  - `id` (PK, Integer, autoincrement)
  - `user_id` (Integer, FK: users.id, index)
  - `content_date` (String(10), Candidateのcontent_date, index)
  - `session_id` (Integer, FK: recent_review_problem_sessions.id, nullable, index)
  - `used_at` (DateTime(timezone=True), server_default=func.now())
  - `source_type` (String(50), index)
  - `source_id` (Integer/BigInteger, index)
  - `sub_id` (Integer, nullable)
- **インデックス**:
  - `(user_id, source_type, source_id, sub_id)` - 除外チェック用
  - `(user_id, used_at)` - 自動削除用
  - `(content_date, used_at)` - 自動削除用
- **制約**: なし（同一コンテンツの複数回使用を許容するため）

#### 1.2 マイグレーション
- Alembicマイグレーションファイルを作成
- `content_uses`テーブル作成
- インデックス作成

### フェーズ2: Candidate取得ロジックの実装

#### 2.1 Candidateデータクラスの定義
- **ファイル**: `app/main.py` または新規 `app/candidate.py`
- **クラス**: `Candidate`
  ```python
  @dataclass
  class Candidate:
      source_type: str
      source_id: int
      sub_id: Optional[int]
      content_date: str  # YYYY-MM-DD（ソースの日付）
      subject_id: Optional[int]
      content: str
      priority_score: float
  ```

#### 2.2 各ソースタイプの取得関数

##### 2.2.1 DashboardItem取得
- **関数**: `_fetch_dashboard_item_candidates(db, user_id, study_date) -> list[Candidate]`
- **条件**:
  - `dashboard_date`: 前日〜5日前（当日は含めない）
  - `entry_type = 2 AND status IN (1,4)` を除外
  - `deleted_at IS NULL`
  - 最大50件（フォールバック時は100件）、`dashboard_date ASC, position ASC`（古い順）
- **Candidate生成**:
  - `source_type`: "dashboard_item"
  - `source_id`: `DashboardItem.id`
  - `sub_id`: `None`
  - `content_date`: `dashboard_date`
  - `subject_id`: `subject`
  - `content`: `item + "\n" + memo` (memoが存在する場合)

##### 2.2.2 Review取得
- **関数**: `_fetch_review_candidates(db, user_id, study_date) -> list[Candidate]`
- **条件**:
  - `created_at >= now - 14days`（当日を含む）
  - 古い3件（フォールバック時は5件）、`created_at ASC`（古い順）
- **Candidate生成**:
  - 1答案につき最大5件
  - `review_weakness`のblock_number 1,2
  - `review_important`のblock_number 1,2
  - `review_future`のblock_number 1
  - 5件に足りない場合は順次追加
  - `source_type`: "review_weakness" / "review_important" / "review_future"
  - `source_id`: `Review.id`
  - `sub_id`: `block_number`
  - `content_date`: `created_at.date().isoformat()`
  - `subject_id`: `UserReviewHistory.subject`
  - `content`: 各要素の該当フィールド

##### 2.2.3 ReviewThread取得
- **関数**: `_fetch_review_thread_candidates(db, user_id, study_date) -> list[Candidate]`
- **条件**:
  - `last_message_at >= now - 14days AND last_message_at < 当日の4:00`（当日は含めない）
  - 古い3スレッド（フォールバック時は5スレッド）、`last_message_at ASC`（古い順）
- **Candidate生成**:
  - 1スレッドにつき、`role='user'`のメッセージを取得
  - 3件以上: 最初/真ん中/最後を取得
  - 3件未満: 1件のみ取得
  - 各メッセージ200文字まで（先頭）
  - `\n`で連結
  - `source_type`: "review_thread"
  - `source_id`: `Thread.id`
  - `sub_id`: `None`
  - `content_date`: `last_message_at.date().isoformat()`
  - `subject_id`: `None`
  - `content`: 連結したメッセージ

##### 2.2.4 FreeThread取得
- **関数**: `_fetch_free_thread_candidates(db, user_id, study_date) -> list[Candidate]`
- **条件**: ReviewThreadと同様（当日は含めない）
- **Candidate生成**: ReviewThreadと同様（`source_type`: "free_thread"）

##### 2.2.5 Note取得
- **関数**: `_fetch_note_candidates(db, user_id, study_date) -> list[Candidate]`
- **条件**:
  - `updated_at`: 前日〜5日前の範囲（当日は含めない）
  - その範囲内で`updated_at ASC`、古い3件（古い順）
- **Candidate生成**:
  - `source_type`: "note"
  - `source_id`: `NotePage.id`
  - `sub_id`: `None`
  - `content_date`: `updated_at.date().isoformat()`
  - `subject_id`: `NotePage.section.notebook.subject_id`（NotePage → NoteSection → Notebook経由で取得）
  - `content`: `content`（500文字まで）

#### 2.3 Candidateプールの統合
- **関数**: `_build_candidate_pool(db, user_id, study_date) -> list[Candidate]`
- 全ソースタイプから取得して統合
- 優先度スコア計算（後述）

### フェーズ3: 優先度スコア計算

#### 3.1 優先度スコア計算ロジック
- **関数**: `_calculate_priority_score(candidate: Candidate, study_date: str) -> float`
- **計算式**:
  ```python
  from datetime import datetime
  
  base_score = 100.0
  
  # 日付をdatetimeオブジェクトに変換
  study_dt = datetime.strptime(study_date, "%Y-%m-%d").date()
  content_dt = datetime.strptime(candidate.content_date, "%Y-%m-%d").date()
  
  # 日付の古さ（古いほど高スコア）
  date_diff = (study_dt - content_dt).days
  if date_diff < 0:
      date_score = 0.0  # 未来の日付は最低スコア
  elif date_diff == 0:
      # Reviewのみ当日を含む（他のソースタイプは当日を含めないためここには来ない）
      date_score = 100.0  # 当日（Reviewのみ）
  elif date_diff <= 1:
      date_score = 90.0   # 1日前
  elif date_diff <= 2:
      date_score = 80.0   # 2日前
  elif date_diff <= 3:
      date_score = 70.0   # 3日前
  elif date_diff <= 5:
      date_score = 60.0   # 4-5日前
  else:
      date_score = 50.0   # それ以上（古いほど高スコア）
  
  # ソースタイプによる重み付け
  type_weights = {
      "dashboard_item": 1.0,
      "review_weakness": 1.2,
      "review_important": 1.1,
      "review_future": 1.0,
      "review_thread": 0.9,
      "free_thread": 0.8,
      "note": 0.9,
  }
  type_weight = type_weights.get(candidate.source_type, 1.0)
  
  priority_score = base_score * (date_score / 100.0) * type_weight
  ```
- **注意**: Review以外は当日のものは含めない（取得時に除外）

#### 3.2 優先度順ソート
- `_sort_candidates_by_priority(candidates: list[Candidate]) -> list[Candidate]`
- `priority_score`の降順でソート（古い方が優先）

#### 3.3 最終選択フィルター（priority_score確定後）
- **関数**: `_apply_final_selection_filter(candidates: list[Candidate]) -> list[Candidate]`
- **処理**:
  1. 優先度順にソート済みの候補から選択（各カテゴリ内でも優先度順）
  2. dashboard_itemから2問を優先的に選択（優先度順）
  3. review系（review_weakness/review_important/review_future）から1問を優先的に選択（優先度順）
  4. noteから1問を優先的に選択（優先度順）
  5. 合計5件に満たない場合は、全体の優先度順で補充
- **実装例**:
  ```python
  selected = []
  # dashboard_itemから2問
  dashboard_items = [c for c in candidates if c.source_type == "dashboard_item"]
  selected.extend(dashboard_items[:2])
  # review系から1問
  review_items = [c for c in candidates if c.source_type in ["review_weakness", "review_important", "review_future"]]
  if review_items and len(selected) < 5:
      selected.append(review_items[0])
  # noteから1問
  note_items = [c for c in candidates if c.source_type == "note"]
  if note_items and len(selected) < 5:
      selected.append(note_items[0])
  # 残りを優先度順で補充
  remaining = [c for c in candidates if c not in selected]
  selected.extend(remaining[:5 - len(selected)])
  return selected[:5]
  ```

### フェーズ4: content_uses除外ロジック

#### 4.1 使用済みCandidateの取得
- **関数**: `_get_used_candidate_keys(db, user_id) -> set[tuple]`
- **戻り値**: `{(source_type, source_id, sub_id), ...}` のセット
- **クエリ**: 
  ```python
  used = db.query(
      ContentUse.source_type,
      ContentUse.source_id,
      ContentUse.sub_id
  ).filter(
      ContentUse.user_id == user_id
  ).all()
  return {(u.source_type, u.source_id, u.sub_id) for u in used}
  ```

#### 4.2 除外処理
- **関数**: `_filter_unused_candidates(candidates: list[Candidate], used_keys: set[tuple]) -> list[Candidate]`
- 使用済みを除外

#### 4.3 候補が5件未満の場合の処理（フォールバック）
- **関数**: `_ensure_sufficient_candidates(db, user_id, study_date, candidates: list[Candidate], used_keys: set[tuple], min_count: int = 5) -> list[Candidate]`
- **処理順序**:
  1. **取得制限の緩和**（優先）
     - 各ソースタイプを個別に再取得（制限を緩和）
     - Dashboard: 50→100件で再取得（古い順）
     - Review: 古い3→5件で再取得（古い順）
     - Thread: 古い3→5スレッドで再取得（古い順）
     - Note: 古い3→5件で再取得（古い順）
     - 再取得後、優先度計算と除外処理を適用（同じ除外ルール（content_uses）のまま）
  2. **重複許容モード**（最後の手段）
     - それでも足りない場合のみ
     - 14日除外を部分的に解除（例: `used_at >= now - 3days` だけ除外）
     - 段階的に緩める（3日→1日→0日）
     - 優先順位: review→dashboard→note

### フェーズ5: Candidateプールの保存

#### 5.1 保存方法の提案
- **案1: セッションテーブルにJSONカラム追加**
  - `RecentReviewProblemSession`に`candidate_pool_json`カラムを追加
  - 初回生成時に保存、再生成時に再利用
  - **メリット**: DBで一元管理、トランザクション内で処理可能
  - **デメリット**: テーブルが肥大化する可能性

- **案2: 別テーブルで管理**
  - `candidate_pools`テーブルを作成
  - `(user_id, study_date)`で管理
  - **メリット**: セッションテーブルがスッキリ
  - **デメリット**: テーブルが増える

- **案3: メモリ/Redisキャッシュ**
  - セッション中のみ保持
  - **メリット**: DB負荷なし
  - **デメリット**: サーバー再起動で消失、複数サーバーで共有不可

**推奨**: **案1（セッションテーブルにJSONカラム追加）**
- 実装がシンプル
- トランザクション管理が容易
- デバッグ時に確認しやすい

#### 5.2 実装
- `RecentReviewProblemSession`に`candidate_pool_json`カラム追加（Text, nullable）
- 初回生成時: CandidateプールをJSON化して保存
- 再生成時: 既存の`candidate_pool_json`から読み込み

### フェーズ6: content_usesへの登録

#### 6.1 登録処理
- **関数**: `_register_content_uses(db, user_id, session_id, candidates: list[Candidate])`
- 選択されたCandidate（最大5件）を`content_uses`に登録
- `content_date`はCandidateの`content_date`を使用
- トランザクション内で実行

#### 6.2 エラーハンドリング
- LLM呼び出し失敗時はロールバック
- `content_uses`の登録も取り消し

### フェーズ7: LLM呼び出し部分の修正

#### 7.1 プロンプト生成の修正
- **関数**: `_build_recent_review_prompt_from_candidates(study_date: str, candidates: list[Candidate]) -> str`
- 従来の大量データではなく、選択されたCandidateのみを渡す
- プロンプトテンプレートを修正（`recent_review_problems.txt`）

#### 7.2 プロンプトテンプレートの更新
- `{CANDIDATES_JSON}`プレースホルダーを追加
- 従来の`{DASHBOARD_ITEMS_JSON}`などは削除
- `{PREVIOUS_QUESTIONS_JSON}`は削除（廃止）

### フェーズ8: 自動削除処理

#### 8.1 削除処理の実装
- **関数**: `_cleanup_old_content_uses(db, days: int = 14)`
- **処理**:
  - `used_at < now - 14days`のレコードを削除
  - バッチ処理またはクエリ時に実行
- **実装**: `_get_used_candidate_keys`の前に1回だけ実行（クエリのパフォーマンスを考慮）

#### 8.2 実行タイミング
- **案1: クエリ時に実行**
  - `_get_used_candidate_keys`内で古いレコードを削除
  - **メリット**: 実装がシンプル
  - **デメリット**: クエリが遅くなる可能性

- **案2: バッチ処理**
  - 定期的に実行（例: 1日1回）
  - **メリット**: クエリが高速
  - **デメリット**: バッチ処理の実装が必要

- **案3: ハイブリッド**
  - 通常はクエリ時に削除
  - 大量削除が必要な場合はバッチ処理

**推奨**: **案1（クエリ時に実行）**
- 実装がシンプル
- 14日以上古いレコードは少数のはず
- パフォーマンスへの影響は限定的

### フェーズ9: メインエンドポイントの修正

#### 9.1 POST `/v1/recent-review-problems/sessions`の修正
- **新しいフロー**:
  1. `study_date`取得（4:00境界の学習日）
  2. 制限チェック
  3. **Candidateプール取得/読み込み**:
     - 初回生成: `_build_candidate_pool`で取得
     - 再生成: 同日の最初のセッション（mode="generate"）から`candidate_pool_json`を読み込み
       - セッションが見つからない場合は、新規にCandidateプールを作成
  4. **優先度計算**:
     - `_calculate_priority_score`で各Candidateにスコアを付与
     - `_sort_candidates_by_priority`でソート
  5. **除外処理**:
     - `_get_used_candidate_keys`で使用済みキーを取得
     - `_filter_unused_candidates`で除外
  6. **最終選択フィルター**:
     - `_apply_final_selection_filter`でdashboard/review/noteの優先順位を適用
  7. **フォールバック**:
     - 5件未満の場合は`_ensure_sufficient_candidates`で補完
  8. **セッション作成**（status="failed"）
  9. **トランザクション開始**
  10. **content_uses登録**
  11. **Candidateプール保存**（初回のみ、トランザクション内）
  12. **LLM呼び出し**（トランザクション内）
  13. **成功時**: status="success"、問題を保存、コミット
  14. **失敗時**: ロールバック（content_uses、Candidateプール保存も取り消し）

#### 9.2 トランザクション管理
- Candidate取得・優先度計算: トランザクション外
- content_uses登録〜LLM呼び出し: トランザクション内
- LLM呼び出し失敗時: ロールバック

### フェーズ10: エラーハンドリング

#### 10.1 エラーケース
1. **Candidateプールが空**
   - エラーメッセージ: "復習問題を生成するためのデータがありません"
   - status="failed"

2. **候補が5件未満で補完もできない**
   - エラーメッセージ: "十分な復習材料が見つかりませんでした"
   - status="failed"

3. **CandidateプールのJSON読み込み失敗**（再生成時）
   - エラーメッセージ: "候補プールの読み込みに失敗しました"
   - 新規にCandidateプールを作成して続行

4. **優先度計算時のエラー**（日付フォーマット不正など）
   - エラーメッセージ: "優先度計算中にエラーが発生しました"
   - 該当Candidateをスキップして続行

5. **content_uses登録時の重複エラー**（同一セッションでの重複リクエスト）
   - エラーメッセージ: "既に登録済みです"
   - 既存のcontent_usesを確認して続行

6. **LLM呼び出し失敗**
   - ロールバック
   - status="failed"
   - error_messageに詳細を記録

7. **DBエラー**
   - 適切なエラーハンドリング
   - ロールバック

### フェーズ11: テスト・検証

#### 11.1 単体テスト
- 各取得関数のテスト
- 優先度計算のテスト
- 除外ロジックのテスト

#### 11.2 統合テスト
- エンドポイントのテスト
- トランザクション管理のテスト
- エラーハンドリングのテスト

## 実装順序

1. **フェーズ1**: データベーススキーマ追加
2. **フェーズ2**: Candidate取得ロジック
3. **フェーズ3**: 優先度スコア計算
4. **フェーズ4**: content_uses除外ロジック
5. **フェーズ5**: Candidateプールの保存
6. **フェーズ6**: content_usesへの登録
7. **フェーズ7**: LLM呼び出し部分の修正
8. **フェーズ8**: 自動削除処理
9. **フェーズ9**: メインエンドポイントの修正
10. **フェーズ10**: エラーハンドリング
11. **フェーズ11**: テスト・検証

## 命名規則の注意事項

### study_date vs content_date
- **`study_date`**: セッション側の学習日（4:00境界で計算される生成日）
  - `RecentReviewProblemSession.study_date`として既に存在
  - 生成日を表す
- **`content_date`**: Candidate側のコンテンツの日付（ソースの日付）
  - `Candidate.content_date`として使用
  - `ContentUse.content_date`として保存
  - ソースの鮮度基準（dashboard_date / created_at / last_message_at / updated_at）

この命名により、将来の混乱を防ぎます。

## 確認事項

### 1. priority_scoreの計算方法
- 日付が古い方が優先（新しい方が優先ではない）
- Review以外は当日のものは含めない（前日以降）
- Reviewのみ当日のものからも復習問題が出る

### 2. Candidateプールの保存方法
セッションテーブルにJSONカラム追加を推奨しますが、他の方法も検討可能です。

### 3. 候補が5件未満の場合の処理
- 優先順位: 取得制限の緩和 → 重複許容モード
- 重複許容モード時の優先順位: review→dashboard→note

### 4. ReviewThread/FreeThreadのsubject_id
現状、Threadにはsubject_idがありません。ReviewThreadの場合は`None`で進めます。

### 5. Noteのsubject_id
NotePage → NoteSection → Notebook経由で`subject_id`を取得（Notebook.subject_id）

### 6. 改行文字
メッセージの連結は`\n`（バックスラッシュn）を使用。`/n`（スラッシュn）ではない。

## 次のステップ

実装計画に問題がなければ、フェーズ1から順次実装を開始します。
