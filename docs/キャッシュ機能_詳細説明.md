# キャッシュ機能の詳細説明

## 概要

キャッシュ機能は、同じ入力（問題文・答案・出題趣旨）に対するLLM評価結果をデータベースに保存し、再評価時にAPI呼び出しをスキップしてコストを削減する機能です。

## なぜキャッシュが必要か

### 現状の問題

1. **同じ答案の再評価で毎回API呼び出しが発生**
   - ユーザーが同じ答案を再度評価する場合
   - 複数のユーザーが同じ問題・答案を評価する場合
   - システムの再起動やエラー後の再評価

2. **コストの無駄**
   - 同じ入力に対して同じ出力が生成されるのに、毎回APIコストが発生
   - 特に長い答案の場合、1回の評価で数千〜数万トークンを使用

3. **レスポンス時間の改善**
   - API呼び出しをスキップすることで、レスポンス時間が大幅に短縮（数秒→数ミリ秒）

## キャッシュの仕組み

### 基本的な流れ

```
1. 評価リクエスト受信
   ↓
2. 入力データからハッシュを計算
   - 問題文 (question_text)
   - 答案 (answer_text)
   - 出題趣旨 (purpose_text)
   - 採点実感 (grading_impression_text)
   - 科目 (subject)
   - プロンプトバージョン (prompt_version)
   ↓
3. キャッシュテーブルでハッシュを検索
   ↓
4. キャッシュヒット？
   ├─ YES → キャッシュから結果を返す（API呼び出しなし）
   └─ NO  → LLM APIを呼び出し、結果をキャッシュに保存して返す
```

### ハッシュの計算方法

入力データを正規化してからハッシュを計算します：

```python
import hashlib
import json

def calculate_cache_hash(
    subject: str,
    question_text: Optional[str],
    answer_text: str,
    purpose_text: Optional[str],
    grading_impression_text: Optional[str],
    prompt_version: str = "1.0"  # プロンプトのバージョン
) -> str:
    """
    キャッシュキーとなるハッシュを計算
    
    入力データを正規化（空白の統一、改行の統一など）してから
    SHA256ハッシュを計算します。
    """
    # データを正規化
    normalized = {
        "subject": subject.strip(),
        "question_text": (question_text or "").strip(),
        "answer_text": answer_text.strip(),
        "purpose_text": (purpose_text or "").strip(),
        "grading_impression_text": (grading_impression_text or "").strip(),
        "prompt_version": prompt_version
    }
    
    # JSON文字列に変換（ソートして一貫性を保つ）
    json_str = json.dumps(normalized, sort_keys=True, ensure_ascii=False)
    
    # SHA256ハッシュを計算
    hash_obj = hashlib.sha256(json_str.encode('utf-8'))
    return hash_obj.hexdigest()
```

### データベース設計

新しいテーブル `review_cache` を作成します：

```python
class ReviewCache(Base):
    """
    講評結果のキャッシュテーブル
    
    設計のポイント:
    - 入力データのハッシュをキーとして結果を保存
    - プロンプトバージョンも含めてキャッシュキーに含める
    - 有効期限を設定（デフォルト30日）
    - キャッシュサイズを制限（古いものから削除）
    """
    __tablename__ = "review_cache"
    
    id = Column(BigInteger().with_variant(Integer, "sqlite"), primary_key=True, autoincrement=True)
    
    # キャッシュキー
    cache_hash = Column(String(64), nullable=False, unique=True, index=True)  # SHA256ハッシュ（64文字）
    
    # 入力データ（検証用、デバッグ用）
    subject = Column(String(50), nullable=False)
    question_text = Column(Text, nullable=True)
    answer_text = Column(Text, nullable=False)  # 長いので要約版を保存することも検討
    purpose_text = Column(Text, nullable=True)
    grading_impression_text = Column(Text, nullable=True)
    prompt_version = Column(String(20), nullable=False, default="1.0")
    
    # キャッシュされた結果
    review_json = Column(JSONB if _use_jsonb else Text, nullable=False)  # LLMの評価結果（JSON）
    review_markdown = Column(Text, nullable=False)  # マークダウン形式の講評
    
    # メタデータ
    model_name = Column(String(100), nullable=True)  # 使用したモデル名
    input_tokens = Column(Integer, nullable=True)  # 入力トークン数（参考用）
    output_tokens = Column(Integer, nullable=True)  # 出力トークン数（参考用）
    
    # タイムスタンプ
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    last_accessed_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)  # 最終アクセス時刻
    expires_at = Column(DateTime(timezone=True), nullable=True)  # 有効期限（NULLの場合は無期限）
    
    # アクセス統計
    hit_count = Column(Integer, nullable=False, default=0)  # キャッシュヒット回数
    
    __table_args__ = (
        Index('idx_cache_hash', 'cache_hash'),
        Index('idx_cache_expires', 'expires_at'),
        Index('idx_cache_last_accessed', 'last_accessed_at'),
    )
```

## 実装方法

### 1. キャッシュ検索関数

```python
def get_cached_review(
    db: Session,
    cache_hash: str,
    max_age_days: int = 30
) -> Optional[ReviewCache]:
    """
    キャッシュから講評結果を取得
    
    Args:
        db: データベースセッション
        cache_hash: キャッシュハッシュ
        max_age_days: キャッシュの最大有効期限（日数）
    
    Returns:
        キャッシュが見つかった場合はReviewCacheオブジェクト、なければNone
    """
    from datetime import datetime, timedelta
    from zoneinfo import ZoneInfo
    
    # 有効期限をチェック
    cutoff_date = datetime.now(ZoneInfo("UTC")) - timedelta(days=max_age_days)
    
    cache = db.query(ReviewCache).filter(
        ReviewCache.cache_hash == cache_hash,
        or_(
            ReviewCache.expires_at.is_(None),
            ReviewCache.expires_at > datetime.now(ZoneInfo("UTC"))
        ),
        ReviewCache.created_at > cutoff_date
    ).first()
    
    if cache:
        # アクセス統計を更新
        cache.last_accessed_at = datetime.now(ZoneInfo("UTC"))
        cache.hit_count += 1
        db.commit()
    
    return cache
```

### 2. キャッシュ保存関数

```python
def save_review_cache(
    db: Session,
    cache_hash: str,
    subject: str,
    question_text: Optional[str],
    answer_text: str,
    purpose_text: Optional[str],
    grading_impression_text: Optional[str],
    prompt_version: str,
    review_json: Dict[str, Any],
    review_markdown: str,
    model_name: str,
    input_tokens: Optional[int],
    output_tokens: Optional[int],
    expires_days: int = 30
) -> ReviewCache:
    """
    講評結果をキャッシュに保存
    
    Args:
        db: データベースセッション
        cache_hash: キャッシュハッシュ
        ... (その他のパラメータ)
        expires_days: 有効期限（日数、0の場合は無期限）
    
    Returns:
        保存されたReviewCacheオブジェクト
    """
    from datetime import datetime, timedelta
    from zoneinfo import ZoneInfo
    
    expires_at = None
    if expires_days > 0:
        expires_at = datetime.now(ZoneInfo("UTC")) + timedelta(days=expires_days)
    
    cache = ReviewCache(
        cache_hash=cache_hash,
        subject=subject,
        question_text=question_text,
        answer_text=answer_text[:1000] if answer_text else None,  # 長い答案は要約版を保存
        purpose_text=purpose_text,
        grading_impression_text=grading_impression_text,
        prompt_version=prompt_version,
        review_json=review_json,
        review_markdown=review_markdown,
        model_name=model_name,
        input_tokens=input_tokens,
        output_tokens=output_tokens,
        expires_at=expires_at,
        hit_count=0
    )
    
    db.add(cache)
    db.commit()
    db.refresh(cache)
    
    return cache
```

### 3. generate_review関数の修正

```python
def generate_review(
    subject: str,
    question_text: Optional[str],
    answer_text: str,
    purpose_text: Optional[str] = None,
    grading_impression_text: Optional[str] = None,
    db: Optional[Session] = None,  # キャッシュ用にDBセッションを追加
    use_cache: bool = True,  # キャッシュを使用するか
    force_refresh: bool = False,  # 強制的に再評価するか
) -> tuple[str, Dict[str, Any], str, Optional[int], Optional[int], Optional[str], Optional[int]]:
    """
    LLMを使って答案の講評を生成する（キャッシュ対応版）
    
    Args:
        ... (既存のパラメータ)
        db: データベースセッション（キャッシュ用）
        use_cache: キャッシュを使用するか（デフォルト: True）
        force_refresh: 強制的に再評価するか（デフォルト: False）
    
    Returns:
        tuple: (review_markdown, review_json, model_name, input_tokens, output_tokens, request_id, latency_ms)
    """
    # プロンプトバージョンを取得（環境変数またはデフォルト値）
    prompt_version = os.getenv("PROMPT_VERSION", "1.0")
    
    # キャッシュハッシュを計算
    cache_hash = calculate_cache_hash(
        subject=subject,
        question_text=question_text,
        answer_text=answer_text,
        purpose_text=purpose_text,
        grading_impression_text=grading_impression_text,
        prompt_version=prompt_version
    )
    
    # キャッシュを検索（use_cache=True かつ force_refresh=False の場合）
    if use_cache and not force_refresh and db:
        cached = get_cached_review(db, cache_hash)
        if cached:
            print(f"キャッシュヒット: {cache_hash[:16]}... (ヒット回数: {cached.hit_count})")
            return (
                cached.review_markdown,
                cached.review_json if isinstance(cached.review_json, dict) else json.loads(cached.review_json),
                cached.model_name or "cached",
                cached.input_tokens,
                cached.output_tokens,
                None,  # request_idはキャッシュには保存しない
                None,  # latency_msはキャッシュには保存しない
            )
    
    # キャッシュミスまたは強制再評価の場合は通常通りLLM APIを呼び出し
    print("キャッシュミス: LLM APIを呼び出します...")
    
    # LLM設定を取得
    llm_config = get_llm_config()
    
    # APIキーが設定されていない場合はダミーを返す
    if not llm_config.is_available():
        review_markdown, review_json, model_name = _generate_dummy_review(subject)
        return review_markdown, review_json, model_name, None, None, None, None
    
    try:
        client = llm_config.get_client()
        model_name = llm_config.get_model(USE_CASE_REVIEW)
        
        # ===== 答案の評価（1段階処理） =====
        print("答案の評価を開始...")
        evaluation_result, usage = _evaluate_answer(
            client,
            subject,
            question_text,
            answer_text,
            purpose_text,
            grading_impression_text,
            model_name,
        )
        
        # ===== 講評JSONを構築（evaluationのみ保持） =====
        review_json = {
            "evaluation": evaluation_result
        }
        
        # マークダウン形式の講評を生成
        review_markdown = _format_markdown(subject, review_json)
        
        # キャッシュに保存（use_cache=True かつ dbが提供されている場合）
        if use_cache and db:
            try:
                save_review_cache(
                    db=db,
                    cache_hash=cache_hash,
                    subject=subject,
                    question_text=question_text,
                    answer_text=answer_text,
                    purpose_text=purpose_text,
                    grading_impression_text=grading_impression_text,
                    prompt_version=prompt_version,
                    review_json=review_json,
                    review_markdown=review_markdown,
                    model_name=model_name,
                    input_tokens=usage.get("input_tokens"),
                    output_tokens=usage.get("output_tokens"),
                    expires_days=30
                )
                print(f"キャッシュに保存しました: {cache_hash[:16]}...")
            except Exception as e:
                # キャッシュ保存エラーは無視（評価結果は返す）
                print(f"キャッシュ保存エラー（無視）: {e}")
        
        return (
            review_markdown,
            review_json,
            model_name,
            usage.get("input_tokens"),
            usage.get("output_tokens"),
            usage.get("request_id"),
            usage.get("latency_ms"),
        )
        
    except Exception as e:
        # エラー処理（既存のコードと同じ）
        import traceback
        error_detail = traceback.format_exc()
        print(f"LLM生成エラー: {e}\n{error_detail}")
        raise Exception(f"講評生成中にエラーが発生しました: {str(e)}") from e
```

### 4. main.pyのエンドポイント修正

```python
@app.post("/v1/reviews", response_model=ReviewResponse)
def create_review(
    request: ReviewRequest,
    db: Session = Depends(get_db),
    current_user: Optional[User] = Depends(get_current_user_optional)
):
    """
    講評を生成（キャッシュ対応）
    """
    # ... (既存のコード)
    
    # キャッシュを使用して講評を生成
    review_markdown, review_json, model_name, input_tokens, output_tokens, request_id, latency_ms = generate_review(
        subject=subject_name,
        question_text=question_text,
        answer_text=request.answer_text,
        purpose_text=purpose_text,
        grading_impression_text=grading_impression_text,
        db=db,  # DBセッションを渡す
        use_cache=True,  # キャッシュを使用
        force_refresh=request.force_refresh if hasattr(request, 'force_refresh') else False
    )
    
    # ... (既存のコード)
```

## メリット・デメリット

### メリット

1. **コスト削減**
   - 同じ入力に対する再評価で100%コスト削減
   - キャッシュヒット率が高い場合、全体で30-50%のコスト削減が期待できる

2. **レスポンス時間の短縮**
   - API呼び出しをスキップすることで、数秒→数ミリ秒に短縮

3. **APIレート制限の回避**
   - キャッシュヒット時はAPI呼び出しがないため、レート制限に引っかかりにくい

4. **一貫性の向上**
   - 同じ入力に対して常に同じ結果を返す（プロンプトバージョンが同じ場合）

### デメリット・注意点

1. **プロンプト変更時の対応**
   - プロンプトを変更した場合、`prompt_version`を更新する必要がある
   - 古いキャッシュは自動的に無効化される

2. **ストレージ使用量**
   - キャッシュが増えるとデータベースサイズが増加
   - 定期的なクリーンアップが必要

3. **キャッシュの有効期限**
   - 長すぎると古い結果が返される可能性
   - 短すぎるとキャッシュの効果が薄い

4. **デバッグの複雑化**
   - キャッシュヒット時はLLM APIが呼ばれないため、デバッグがやや複雑になる

## キャッシュ管理機能

### キャッシュのクリーンアップ

```python
def cleanup_old_cache(db: Session, max_age_days: int = 30, max_size: int = 10000):
    """
    古いキャッシュを削除
    
    Args:
        db: データベースセッション
        max_age_days: この日数以上古いキャッシュを削除
        max_size: キャッシュの最大件数（超えた場合は古いものから削除）
    """
    from datetime import datetime, timedelta
    from zoneinfo import ZoneInfo
    
    cutoff_date = datetime.now(ZoneInfo("UTC")) - timedelta(days=max_age_days)
    
    # 有効期限切れのキャッシュを削除
    deleted_expired = db.query(ReviewCache).filter(
        ReviewCache.expires_at.isnot(None),
        ReviewCache.expires_at < datetime.now(ZoneInfo("UTC"))
    ).delete()
    
    # 古いキャッシュを削除
    deleted_old = db.query(ReviewCache).filter(
        ReviewCache.created_at < cutoff_date
    ).delete()
    
    # サイズ制限を超えている場合は、アクセス頻度の低いものから削除
    total_count = db.query(ReviewCache).count()
    if total_count > max_size:
        to_delete = total_count - max_size
        # 最終アクセス時刻が古いものから削除
        old_caches = db.query(ReviewCache).order_by(
            ReviewCache.last_accessed_at.asc()
        ).limit(to_delete).all()
        
        for cache in old_caches:
            db.delete(cache)
    
    db.commit()
    
    return {
        "deleted_expired": deleted_expired,
        "deleted_old": deleted_old,
        "deleted_by_size": to_delete if total_count > max_size else 0
    }
```

### キャッシュ統計の取得

```python
def get_cache_stats(db: Session) -> Dict[str, Any]:
    """
    キャッシュの統計情報を取得
    
    Returns:
        キャッシュの統計情報（総件数、ヒット率など）
    """
    total = db.query(ReviewCache).count()
    total_hits = db.query(func.sum(ReviewCache.hit_count)).scalar() or 0
    
    # 最近30日間のアクセス
    from datetime import datetime, timedelta
    from zoneinfo import ZoneInfo
    cutoff = datetime.now(ZoneInfo("UTC")) - timedelta(days=30)
    recent = db.query(ReviewCache).filter(
        ReviewCache.last_accessed_at >= cutoff
    ).count()
    
    return {
        "total_caches": total,
        "total_hits": total_hits,
        "recent_accessed": recent,
        "average_hits_per_cache": total_hits / total if total > 0 else 0
    }
```

## 実装の優先順位

1. **Phase 1: 基本実装**
   - `ReviewCache`テーブルの作成
   - `calculate_cache_hash`関数の実装
   - `get_cached_review`と`save_review_cache`関数の実装
   - `generate_review`関数の修正

2. **Phase 2: 管理機能**
   - キャッシュクリーンアップ機能
   - キャッシュ統計の取得
   - 管理画面でのキャッシュ管理（オプション）

3. **Phase 3: 最適化**
   - キャッシュサイズの最適化（長い答案の要約保存など）
   - キャッシュヒット率のモニタリング
   - 有効期限の動的調整

## 期待される効果

- **コスト削減**: キャッシュヒット率が50%の場合、全体で約50%のコスト削減
- **レスポンス時間**: キャッシュヒット時は数秒→数ミリ秒に短縮
- **スケーラビリティ**: 同じ問題を複数のユーザーが評価する場合のコストが大幅に削減
