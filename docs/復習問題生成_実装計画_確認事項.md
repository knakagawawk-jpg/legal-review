# 復習問題生成機能リニューアル - 実装計画確認事項

## 確認した問題点と改善提案

### 1. フォールバック処理の記述不一致（仕様書側）

**問題**: 仕様書のフォールバック処理に「Review: 最新3→5件」と記載されているが、取得条件は「古い順」に統一されている。

**修正**: 仕様書を「Review: 古い3→5件」に修正すべき。

### 2. 最終選択フィルターの実装詳細が不明確

**問題**: `_apply_final_selection_filter`の実装詳細が不明確。
- 優先度順にソート済みの候補から、各カテゴリ（dashboard/review/note）から選択する際のロジックが不明確
- 各カテゴリ内で優先度順に選択するのか、全体の優先度順から選択するのか

**提案**: 
```python
def _apply_final_selection_filter(candidates: list[Candidate]) -> list[Candidate]:
    """
    優先度順にソート済みの候補から、以下の優先順位で選択：
    1. dashboard_itemから2問（優先度順）
    2. review系から1問（優先度順）
    3. noteから1問（優先度順）
    4. 合計5件に満たない場合は、全体の優先度順で補充
    """
    selected = []
    
    # 1. dashboard_itemから2問
    dashboard_items = [c for c in candidates if c.source_type == "dashboard_item"]
    selected.extend(dashboard_items[:2])
    
    # 2. review系から1問
    review_items = [c for c in candidates if c.source_type in ["review_weakness", "review_important", "review_future"]]
    if review_items and len(selected) < 5:
        selected.append(review_items[0])
    
    # 3. noteから1問
    note_items = [c for c in candidates if c.source_type == "note"]
    if note_items and len(selected) < 5:
        selected.append(note_items[0])
    
    # 4. 残りを優先度順で補充
    remaining = [c for c in candidates if c not in selected]
    selected.extend(remaining[:5 - len(selected)])
    
    return selected[:5]
```

### 3. 再生成時のCandidateプール読み込みと除外処理のタイミング

**問題**: 再生成時に既存の`candidate_pool_json`から読み込んだ後、content_usesで除外するタイミングが不明確。

**確認**: フロー9.1のステップ3で「既存セッションから`candidate_pool_json`を読み込み」とあるが、どのセッションから読み込むのか？

**提案**: 
- 同日の最初のセッション（mode="generate"）から読み込む
- または、最新の成功セッションから読み込む
- 読み込み後、ステップ5で除外処理を適用

### 4. フォールバック処理の実装詳細

**問題**: `_ensure_sufficient_candidates`の実装詳細が不明確。
- 取得制限の緩和時に、各ソースタイプを個別に再取得するのか、全体を再取得するのか
- 再取得後、除外処理を適用するが、その際のused_keysは更新するのか

**提案**:
```python
def _ensure_sufficient_candidates(
    db, user_id, study_date, candidates: list[Candidate], 
    used_keys: set[tuple], min_count: int = 5
) -> list[Candidate]:
    """
    候補が5件未満の場合のフォールバック処理
    """
    if len(candidates) >= min_count:
        return candidates
    
    # 1. 取得制限の緩和
    # 各ソースタイプを個別に再取得（制限を緩和）
    expanded_candidates = []
    
    # Dashboard: 50→100件
    dash_candidates = _fetch_dashboard_item_candidates(db, user_id, study_date, limit=100)
    expanded_candidates.extend(dash_candidates)
    
    # Review: 3→5件
    review_candidates = _fetch_review_candidates(db, user_id, study_date, limit=5)
    expanded_candidates.extend(review_candidates)
    
    # Thread: 3→5スレッド
    thread_candidates = _fetch_review_thread_candidates(db, user_id, study_date, limit=5)
    expanded_candidates.extend(thread_candidates)
    free_thread_candidates = _fetch_free_thread_candidates(db, user_id, study_date, limit=5)
    expanded_candidates.extend(free_thread_candidates)
    
    # Note: 3→5件
    note_candidates = _fetch_note_candidates(db, user_id, study_date, limit=5)
    expanded_candidates.extend(note_candidates)
    
    # 優先度計算と除外処理
    for c in expanded_candidates:
        c.priority_score = _calculate_priority_score(c, study_date)
    
    expanded_candidates = _sort_candidates_by_priority(expanded_candidates)
    expanded_candidates = _filter_unused_candidates(expanded_candidates, used_keys)
    
    if len(expanded_candidates) >= min_count:
        return expanded_candidates
    
    # 2. 重複許容モード（最後の手段）
    # 14日除外を部分的に解除（例: 3日のみ除外）
    three_days_ago = datetime.now(ZoneInfo("UTC")) - timedelta(days=3)
    relaxed_used_keys = {
        (u.source_type, u.source_id, u.sub_id)
        for u in db.query(ContentUse).filter(
            ContentUse.user_id == user_id,
            ContentUse.used_at >= three_days_ago
        ).all()
    }
    
    relaxed_candidates = _filter_unused_candidates(expanded_candidates, relaxed_used_keys)
    
    return relaxed_candidates
```

### 5. ReviewThreadの取得方法

**問題**: 現状整理を見ると、ReviewThreadはReviewから取得している（Review.thread_idを使用）が、新システムでは独立して取得する設計になっている。

**確認**: これは意図的な変更か？ReviewThreadを独立して取得する場合、Reviewとの関連性が失われる可能性がある。

**提案**: 
- 仕様書通り、ReviewThreadを独立して取得する（過去2週間、古い3スレッド）
- Reviewとの関連性は保持しない（subject_idもNone）

### 6. 優先度計算の日付比較

**問題**: `date_diff = (study_date - candidate.content_date).days`の計算で、文字列同士の減算はできない。

**修正**: 
```python
from datetime import datetime

def _calculate_priority_score(candidate: Candidate, study_date: str) -> float:
    base_score = 100.0
    
    # 日付をdatetimeオブジェクトに変換
    study_dt = datetime.strptime(study_date, "%Y-%m-%d").date()
    content_dt = datetime.strptime(candidate.content_date, "%Y-%m-%d").date()
    
    # 日付の古さ（古いほど高スコア）
    date_diff = (study_dt - content_dt).days
    # ... 以下同様
```

### 7. content_usesの自動削除処理のタイミング

**問題**: `_get_used_candidate_keys`内で自動削除を実行する場合、クエリのパフォーマンスに影響する可能性がある。

**提案**: 
- 削除処理を別関数に分離
- クエリ前に削除を実行（1回のみ）
- または、バックグラウンドジョブで定期的に削除

### 8. エラーハンドリングの詳細

**問題**: エラーハンドリングの詳細が不足している。

**追加すべきエラーケース**:
- CandidateプールのJSON読み込み失敗
- 優先度計算時のエラー（日付フォーマット不正など）
- content_uses登録時の重複エラー（同一セッションでの重複リクエスト）

### 9. トランザクション管理の詳細

**問題**: トランザクションの範囲が不明確。

**確認**: 
- Candidate取得・優先度計算: トランザクション外（OK）
- content_uses登録〜LLM呼び出し: トランザクション内（OK）
- Candidateプール保存: トランザクション内か？

**提案**: Candidateプール保存もトランザクション内で実行（ステップ9と10を統合）

### 10. 同日再生成時のセッション選択

**問題**: 再生成時にどのセッションから`candidate_pool_json`を読み込むのか不明確。

**提案**: 
- 同日の最初のセッション（mode="generate"）から読み込む
- または、最新の成功セッションから読み込む
- セッションが見つからない場合は、新規にCandidateプールを作成

## 実装前に確認すべき事項

1. **ReviewThreadの取得方法**: Reviewから取得するか、独立して取得するか
2. **再生成時のセッション選択**: どのセッションからCandidateプールを読み込むか
3. **フォールバック処理の詳細**: 実装方法の確認
4. **最終選択フィルター**: 実装ロジックの確認

## 推奨される修正

1. 仕様書のフォールバック処理を「古い3→5件」に修正
2. 実装計画に上記の詳細な実装ロジックを追加
3. エラーハンドリングの詳細を追加
4. トランザクション管理の詳細を明確化
